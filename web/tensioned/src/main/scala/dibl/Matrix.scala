/*
 Copyright 2015 Jo Pol
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see http://www.gnu.org/licenses/gpl.html dibl
*/
package dibl

import scala.collection.immutable.HashMap

object Matrix {

  /** Creates a checkerboard-matrix from a brick-matrix by 
    * adding two half bricks to the bottom of the brick-matrix.
    * In ascii-art:
    * <pre>
    * +-------+
    * | a   b |
    * | c   d |
    * +---+---+
    *   b | a 
    *   d | c 
    * +---+---+
    * </pre>
    */
  def toCheckerboard(m: M): M = {
    val rows = m.length
    val cols = m(0).length
    val result: M = Array.ofDim[SrcNodes](2*rows, cols)
    for {
      row <- m.indices
      col <- m(0).indices
    } {
      result(row)(col) = m(row)(col)
      result(row+rows)((col+cols/2)%cols) = m(row)(col)
    }
    result
  }

  /** Converts relative source nodes in one matrix into
    * absolute source nodes in a matrix wih different dimensions.
    */
  def toAbsSources(rel: M, absRows: Int, absCols: Int): M = {
    val abs: M = Array.ofDim[SrcNodes](absRows, absCols)
    val relRows = rel.length
    val relCols = rel(0).length
    for {
      absRow <- abs.indices
      absCol <- abs(0).indices
    } {
      abs(absRow)(absCol) = for ( (relRow,relCol) <- rel (absRow%relRows) (absCol%relCols) )
        yield (absRow + relRow, absCol + relCol)
    }
    abs
  }

  /** Converts relative source nodes in one matrix into
    * absolute source nodes in a matrix wih different dimensions.
    * The margin has nodes for loose end.
    * <pre>
    * ::v v::
    * > o o <
    * > o o <
    * ::^ ^::
    * </pre>
    * In above ascii art each "o" represent a node for a stitch, matching an element in the matrix.
    * "::" represent invisible nodes created for simplicity. 
    * The other symbols match two nodes for (potential) new pairs or for pairs of bobbins.    
    */
  def toAbsWithMargins(rel: M, absRows: Int, absCols: Int): M = {
    val abs = Array.fill(absRows + 4,absCols + 4)(SrcNodes())
    val relRows = rel.length
    val relCols = rel(0).length
    for {
      absRow <- 2 until absRows + 2
      absCol <- 2 until absCols + 2
    } {
      abs(absRow)(absCol) = for ( (relRow,relCol) <- rel (absRow%relRows) (absCol%relCols) )
        yield (absRow + relRow, absCol + relCol)
    }

    { val links = countLinks(abs)
      val lastRow = abs.length - 3
      for (col <- 2 until abs(0).length) {
        // top margin
        abs(2)(col) = for ( (srcRow,srcCol) <- abs(2)(col) )
          yield (srcRow, srcCol - (srcCol - col + 1)%2)
        // bottom margin
        val n = links(lastRow)(col)
        if (n == 2          ) abs(lastRow+1)(col) = SrcNodes((lastRow,col))
        if (n == 2 || n == 3) abs(lastRow+2)(col) = SrcNodes((lastRow,col))
      }
    }
    // footsides
    { val links = countLinks(abs)
      val lastCol = abs(0).length - 3
      for (row <- 0 until abs.length) {
        if(links(row)(2      )==3) abs(row)(0        ) = SrcNodes((row ,2))
        if(links(row)(lastCol)==3) abs(row)(lastCol+2) = SrcNodes((row,lastCol))
      }
    }
    // result
    abs
  }
  
  def inTopMargin (node: (Int, Int)): Boolean = {
    val (row,col) = node
    row < 2
  }
  
  def inLeftMargin (node: (Int, Int)): Boolean = {
    val (row,col) = node
    col < 2
  }

  def countLinks(m: M): Array[Array[Int]] = {
    val links = Array.fill(m.length,m(0).length)(0)
    for {row <- m.indices
         col <- m(row).indices
        } {
      links(row)(col) += m(row)(col).length
      for {(srcRow,srcCol) <- m(row)(col)} links(srcRow)(srcCol) += 1
    }
    links
  }  
  /** Each string represents a matrix generated by Veronika Irvine.
    * Each cell (alias character) represents a target node in a two-in-two-out directed graph.
    * A dash means a not used node, a digit specifies some configuration of links with source nodes.
    */
  val matrixMap: HashMap[String,Array[String]] = HashMap (
    "2x4" -> Array[String]("83154-7-"),
    "4x2" -> Array[String](),
    "4x4" -> Array[String]()
  )

  /** Translates a character in a matrix string into relative links with source nodes.
    * The source nodes are defined with relative (row,column) numbers.
    * A node can be connected in eight directions, but source nodes are not found downwards.
    * A source node on the right means the same row and the next column hence (0,1).
    * A source node at north west means a previous row and column hence (-1,-1).
    */
  val relSourcesMap: HashMap[Char,SrcNodes] = HashMap (
                                      // ascii art of incoming links for a node
    '0' -> SrcNodes((-1, 1),( 0, 1)), // .../_  
    '1' -> SrcNodes((-1, 0),( 0, 1)), // ..|._  
    '2' -> SrcNodes((-1,-1),( 0, 1)), // .\.._  
    '3' -> SrcNodes(( 0,-1),( 0, 1)), // _..._  
    '4' -> SrcNodes((-1, 0),(-1, 1)), // ..|/.  
    '5' -> SrcNodes((-1,-1),(-1, 1)), // .\./.  
    '6' -> SrcNodes(( 0,-1),(-1, 1)), // _../.  
    '7' -> SrcNodes((-1,-1),(-1, 0)), // .\|..  
    '8' -> SrcNodes(( 0,-1),(-1, 0)), // _.|..  
    '9' -> SrcNodes(( 0,-1),(-1,-1)), // _\...  
    '-' -> SrcNodes()                 // not used node
  )

  def unpack(s: String): R = s.toCharArray.map {
    relSourcesMap.get(_).get
  }

  /** Gets the relative source nodes.
   * @param set key for a set of predefined matrices
   * @param nr sequence number of the matrix in the set
   */
  def getRelSources(set: String, nr: Int): M = {
    val s = matrixMap.get(set).get(nr) // TODO: both set and nr could be invalid
    val cols = set.split("x")(1).toInt // won't fail if previous is OK
    unpack(s).grouped(cols).toArray
  }
}